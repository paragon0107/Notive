# AI 코딩 규칙 (구조/품질 중심)

이 문서는 기능 명세가 아니라 **코드 품질과 구조를 안정적으로 유지하기 위한 작업 규칙**을 정리한 것이다. 프레임워크에 상관없이 적용 가능하며, 이 레포에서는 Next.js/React/TS 환경을 기본 가정으로 한다.

## 1. 모듈/책임 분리
1. 하나의 파일은 하나의 책임만 갖는다.
1. UI는 레이아웃/프리젠테이션 컴포넌트와 데이터/상태 컴포넌트를 분리한다.
1. 데이터 접근, 파싱, 변환 로직은 UI 컴포넌트에서 제거하고 `libs` 또는 `apis` 레이어로 이동한다.
1. 페이지(Route)는 “구성” 역할만 수행하고 비즈니스 로직은 별도 모듈로 분리한다.

## 2. 레이어/의존성 규칙
1. UI 레이어는 `libs`/`apis`의 구현 세부사항을 직접 알지 못하게 한다.
1. `pages` → `routes` → `libs`/`apis` 방향으로만 의존한다.
1. 상위 레이어가 하위 레이어 구현을 import하지 않도록 경계를 지킨다.
1. 순환 의존성은 허용하지 않는다.

## 3. 패키지/폴더 구조 원칙
1. 공통 유틸은 `src/libs`에 둔다.
1. 외부 API/Notion 연동은 `src/apis`에 둔다.
1. 레이아웃/테마/전역 스타일은 `src/layouts`에 둔다.
1. 페이지별 UI 조합은 `src/routes`에 둔다.
1. 파일/폴더명은 기능 단위로 짓되, 축약어 사용을 최소화한다.

## 4. 컴포넌트 설계 규칙
1. 컴포넌트는 최소한의 props만 받도록 설계한다.
1. props는 구조화(객체)보다 명시적 나열을 선호한다.
1. 파생 가능한 값은 props로 넘기지 말고 내부에서 계산한다.
1. 재사용 가능한 컴포넌트는 도메인에 종속되지 않게 설계한다.

## 5. 타입/인터페이스 규칙
1. 공용 타입은 `types` 또는 `libs`에 분리한다.
1. 타입은 데이터 소스에 맞춰 선언하고, UI 전용 타입은 별도로 분리한다.
1. `any` 사용은 금지하고, 불가피하면 이유를 주석으로 남긴다.

## 6. 함수/로직 규칙
1. 함수는 한 가지 역할만 수행한다.
1. 사이드 이펙트는 가능한 한 상위 레이어로 올린다.
1. 예외/에러 처리는 함수 내부에서 삼키지 말고 상위로 전달한다.

## 7. 네이밍 규칙
1. 변수/함수/파일명은 역할과 범위가 드러나게 짓는다.
1. 축약어(예: `cfg`, `mgr`)는 금지한다.
1. Boolean은 `is`, `has`, `can` prefix를 사용한다.

## 8. 에러/로깅 규칙
1. 사용자에게 노출되는 에러 메시지는 명확하고 행동 가능해야 한다.
1. 디버깅용 로그는 최종 코드에서 제거한다.
1. 로깅은 한 곳에서 수집/관리되도록 래핑한다.

## 9. 성능/렌더링 규칙
1. 불필요한 렌더를 줄이기 위해 props와 상태를 최소화한다.
1. 이미지/데이터는 필요한 시점에만 로딩한다.
1. 리스트 렌더링 시 안정적인 key를 사용한다.

## 10. 테스트/검증 규칙
1. 핵심 유틸/파서/변환 로직은 단위 테스트를 작성한다.
1. UI는 스냅샷보다 동작 기반 테스트를 우선한다.
1. 버그 재현 케이스는 테스트로 고정한다.

## 11. 변경 작업 규칙
1. 변경 범위를 최소화하고, 관련 없는 파일은 건드리지 않는다.
1. 리팩터링은 기능 변경과 분리하여 진행한다.
1. 기존 동작에 영향이 큰 변경은 사전 합의 후 진행한다.

## 12. 문서화 규칙
1. 암묵적인 룰은 문서에 남긴다.
1. 도메인 규칙은 `docs/`에 별도 정리한다.
1. 모호한 의도는 주석보다 문서에 남긴다.
